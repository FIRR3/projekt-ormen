document.addEventListener("keydown", inputHandler);
let start = document.getElementById("start");
let reset_game = document.getElementById("reset");
start.addEventListener("click", timer);
reset_game.addEventListener("click", reset);

//food timer
const foodTimerDisplay = document.getElementById("foodTimerDisplay");
const foodTimerBar = document.getElementById("foodTimerBar");
const foodTimerContainer = document.getElementById("foodTimerContainer");
let displayedFoodCount = 10;
let foodTimerEnabled;

//canvas
let canvas = document.getElementById("canvas");
let ctx = canvas.getContext("2d");
var heightRatio = 1; //responsiv canvas
canvas.height = canvas.width * heightRatio; //responsiv canvas

//highscore
const scoreListContainer = document.getElementById("scoreListContainer");
var scoreCounters = scoreListContainer.getElementsByClassName("scoreCount");
//blocks
let enableBlocks = false; //används för om vi ska spawna blocks eller inte
let movingBlocks = document.getElementById("movingBlocks");
//variabel för att det ska finnas borders eller inte
let enableBorders = true;
//variabel för om spelet körs 
let playing = false;

//game settings
let speed = 100;
let score = 0;
let boxSize = 25;
let gridSize = canvas.width / boxSize;


class Snake{
  constructor(){
    this.body = [{x: 10, y: 10},{x: 9, y: 10},{x: 8, y: 10}];
    this.direction ={x: 1, y: 0};
  }
  
  move(){
    const head = {
      x: this.body[0].x + this.direction.x,
      y: this.body[0].y + this.direction.y
    };

    this.body.unshift(head);
    this.body.pop();
    if (enableBorders == false){
      if (head.x >= gridSize) head.x = 0;
      if (head.x < 0) head.x = gridSize - 1;
      if (head.y >= gridSize) head.y = 0;
      if (head.y < 0) head.y = gridSize - 1;
    }
    else{
      if (head.x >= gridSize || head.x < 0 || head.y >= gridSize || head.y < 0){
        reset()
      }
    }
    
    for (let i = 1; i < snake.body.length; i++){
      if (head.x === snake.body[i].x && head.y === snake.body[i].y){
        reset()
      }
    }
    for ( let i = 0; i < blockList.length; i++){
      if (head.x === blockList[i].x / boxSize && head.y === blockList[i].y / boxSize){
        reset()
      }
    }
  }

  draw(){
    ctx.fillStyle = "lightgreen";
    this.body.forEach(segment =>{
      ctx.fillRect(
        segment.x * boxSize,
        segment.y * boxSize,
        boxSize,
        boxSize
      );
    });
  }

  changeDirection(newDirection){
    if (this.direction.x === -newDirection.x && 
      this.direction.y === -newDirection.y) return;
    this.direction = newDirection;
  }

  reset(){
    this.body = [{x: 10, y: 10},{x: 9, y: 10},{x: 8, y: 10}];
    this.direction ={x: 1, y: 0};
  }
  
  eat(){
    if (foodList.length < 1) return;
    else{
      for (let i = 0; i < foodList.length; i++){
        if (this.body[0].x == foodList[i].x / boxSize && this.body[0].y == foodList[i].y / boxSize){
          this.body.push(this.body[this.body.length - 1]);
          score += 1;
          resetFoodTimer()
          foodList.pop()
          if (score % 3 == 0){
            speed *= 0.9;
            clearInterval(time);
            time = setInterval(updateCanvas, speed);
          }
        }   
      }
    }  
  }
}

const snake = new Snake();

//hanterar olika key inputs
function inputHandler(event){
  switch(event.key){
    case "ArrowUp":
    case "w":
    case "W":
      snake.changeDirection({x: 0, y: -1});
      event.preventDefault()
      break;
    case "ArrowDown":
    case "s":
    case "S":
      snake.changeDirection({x: 0, y: 1});
      event.preventDefault()
      break;
    case "ArrowLeft":
    case "a":
    case "A":
      snake.changeDirection({x: -1, y: 0});
      event.preventDefault()
      break;
    case "ArrowRight":
    case "d":
    case "D":
      snake.changeDirection({x: 1, y: 0});
      event.preventDefault()
      break;
    case " ":
      timer()
      break;
    case "r":
    case "R":
      reset()
      break;
  }
}

//checkar levels och uppdateras varje gång en input clickas
function levelCheck(){
  var checked_speed = document.querySelector('input[name = "speed"]:checked');
  var checked_map = document.querySelector('input[name = "map"]:checked');
  var checked_borders = document.querySelector('input[name = "borders"]:checked')
  var checked_blocks = document.querySelector('input[name = "blocks"]:checked')
  var checked_foodTimer = document.querySelector('input[name = "foodTimer"]:checked')	

  //slow, medium & fast speed
  if(checked_speed.value == "slow") speed = 200;
  else if (checked_speed.value == "medium") speed = 100;
  else if (checked_speed.value == "fast") speed = 50;

  //large & small map
  if(checked_map.value == "large"){
    boxSize = 10;
    gridSize = canvas.width / boxSize;
  }
  else if (checked_map.value == "small"){
    boxSize = 25;
    gridSize = canvas.width / boxSize;
  } 
  
  //borders
  if(checked_borders.value == "noBorderPassThrough"){
    enableBorders = true;
    canvas.style.border = "3px solid blue"
  }
  else if(checked_borders.value == "borderPassThrough"){
    enableBorders = false;
    canvas.style.border = "3px solid chocolate"
  }

  //blocks
  if(checked_blocks.value == "noBlocks") enableBlocks = false;
  else if(checked_blocks.value == "haveBlocks" || checked_blocks.value == "movingBlocks") enableBlocks = true;

  //food timer
  if(checked_foodTimer.value == "foodTimerDisable"){
    foodTimerEnabled = false;
    foodTimerContainer.style.display = "none";
  }
  if(checked_foodTimer.value == "foodTimerEnable"){
    foodTimerEnabled = true;
    foodTimerContainer.style.display = "block";
  }

  clearInterval(time)
  time = setInterval(reset, speed);
}
var inputs = document.querySelectorAll(".level-list input");
check = function(){
  levelCheck();
};
[].map.call(inputs, function(elem){
  elem.addEventListener("click", check, false);
});

function updateCanvas(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  snake.move();
  rivalMove();
  snake.draw();
  rivalSnake.draw();
  snake.eat();
  rivalEat();
  food();
  if (movingBlocks.checked) {
    moveBlocksTowardSnake();
  }
  block();
  detectCollisionWithRival();
  document.getElementById("scoreCounter").innerText = score;
}

let time;
let foodTime;   
function timer(){
  playing = !playing; 
  if (playing){
    time = setInterval(updateCanvas, speed);
    foodTime = setInterval(addFood, 2000);
    if(foodTimerEnabled == true) startFoodTimer()
    document.getElementById("start").textContent = "Stop (space)";
  } 
  else if(!playing){
    clearInterval(time);
    clearInterval(foodTime);
    pauseFoodTimer()
    document.getElementById("start").textContent = "Start (space)";
  }
}

let highScoreList = []
function updateScore(x){
  highScoreList.push(x)
  highScoreList.sort(function(a, b){return b-a});

  if (highScoreList.length > 5) highScoreList.pop(-1)

  for (i = 0; i < highScoreList.length; i++){
    scoreCounters[i].innerHTML = highScoreList[i];
    if(scoreCounters[i].classList.contains("active") == false) scoreCounters[i].classList.add("active")
  }
}

function reset() {
  if (playing == true) updateScore(score);
  levelCheck();
  resetFoodTimer();
  snake.reset();
  enemySnake.reset(); // <-- Add this line
  score = 0;
  playing = true;
  timer();
  foodList = [];
  blockList = [];
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  snake.draw();
  if (enableBlocks == true) {
    for (i = 0; i < 10; i++) {
      addBlock();
    }
  }
}

let foodList = [];
function addFood(){
  if (foodList.length < 1){
    //bestämmer en slumpmässig position för matbiten
    let x = Math.floor(Math.random() * (gridSize)) * boxSize;
    let y = Math.floor(Math.random() * (gridSize)) * boxSize;
    let foodPlace = true;
    //om maten rör ormen kommer maten att käkas upp
    for (let i = 0; i < snake.body.length; i++){
      if (x == snake.body[i].x && y == snake.body[i].y){
        for (let i = 0; i < foodList.length; i++){
          if (x == foodList[i].x && y == foodList[i].y){
            foodPlace = false;
          }
        }
      }
    }
    //om en matbit ska spawnas på ett block kommer den raderas och en ny kommer att skapas
    for(i = 0; i < blockList.length; i++){
      if(blockList[i].x == x && blockList[i].y == y){
        foodPlace = false;
        foodList = [];
        addFood();
      }
    }
    if (foodPlace) foodList.push({x,y})
    resetFoodTimer();
    if(foodTimerEnabled == true) startFoodTimer();
  }
}
function food(){
  for (let i = 0; i < foodList.length; i++){
    ctx.fillStyle = "tomato";
    ctx.fillRect(foodList[i].x, foodList[i].y, boxSize, boxSize);
  }
}
function startFoodTimer(){
foodTimerInterval = setInterval(()=>{
    displayedFoodCount -= 1;
    foodTimerDisplay.innerText = displayedFoodCount;
    foodTimerBar.style.width = (displayedFoodCount * 10) + "%";
    if(displayedFoodCount == 0){
      if(snake.body.length != 1) snake.body.pop();
      if (score != 0) score -= 1;
      foodList.pop()
      resetFoodTimer()
    }
  }, 1000)
}
function resetFoodTimer(){
  if(typeof foodTimerInterval !== "undefined"){
    clearInterval(foodTimerInterval);
    displayedFoodCount = 10;
    foodTimerBar.style.width = (displayedFoodCount * 10) + "%";
    foodTimerDisplay.innerText = displayedFoodCount;
  }
}
function pauseFoodTimer(){
  if(typeof foodTimerInterval !== "undefined"){
    clearInterval(foodTimerInterval);
    foodTimerDisplay.innerText = displayedFoodCount;
  }
}


let blockList = [];
let blockMoveCounter = 0;
const blockMoveInterval = 1; // move every x updateCanvas() calls
function addBlock(){
  if (blockList.length < 10){
    let x = Math.floor(Math.random() * (gridSize)) * boxSize;
    let y = Math.floor(Math.random() * (gridSize)) * boxSize;
    let blockPlace = true;
    for (let i = 0; i < snake.body.length; i++){
      if (x == snake.body[i].x && y == snake.body[i].y){
        for (let i = 0; i < blockList.length; i++){
          if (x == blockList[i].x && y == blockList[i].y) blockPlace = false;
        }
      }
    }
    if (blockList)blockList.push({x,y})
  }
  else return;
}
function block(){
  if (enableBlocks == true){
    for (let i = 0; i < blockList.length; i++){
      ctx.fillStyle = "blue";
      ctx.fillRect(blockList[i].x, blockList[i].y, boxSize, boxSize);
    }
  }
  else return;
}
function seeking(startX, startY, targetX, targetY){
  let queue = [[startX, startY]];
  let visited = new Set();
  let cameFrom = {};
  visited.add(`${startX},${startY}`);

  const directions = [
    [0, -1], // up
    [0, 1],  // down
    [-1, 0], // left
    [1, 0],  // right
  ];

  while (queue.length > 0) {
    let [x, y] = queue.shift();

    if (x === targetX && y === targetY) {
      // Reconstruct path
      let path = [];
      while (`${x},${y}` !== `${startX},${startY}`) {
        path.unshift([x, y]);
        [x, y] = cameFrom[`${x},${y}`];
      }
      return path;
    }

    for (let [dx, dy] of directions) {
      let nx = x + dx;
      let ny = y + dy;
      let key = `${nx},${ny}`;

      if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize &&!visited.has(key) &&isCellFree(nx, ny))visited.add;
    }
  }
}
function moveBlocksTowardSnake(){
  blockMoveCounter++;
  if (blockMoveCounter < blockMoveInterval) return;
  blockMoveCounter = 0;

  const head = snake.body[0];

  for (let block of blockList){
    // Initialize individual cooldown if it doesn't exist
    if (block.moveCooldown === undefined) {
      block.moveCooldown = Math.floor(Math.random() * 5) + 3;
    }

    // Decrease cooldown and skip if not ready
    block.moveCooldown--;
    if (block.moveCooldown > 0) continue;

    // Reset cooldown randomly (controls how slow each block moves)
    block.moveCooldown = 4 + Math.floor(Math.random() * 5);

    // Calculate direction toward snake's head
    const dx = head.x - block.x / boxSize;
    const dy = head.y - block.y / boxSize;

    // Determine the next position in pixels
    let nextX = block.x;
    let nextY = block.y;
    if (Math.abs(dx) > Math.abs(dy)) {
      nextX += Math.sign(dx) * boxSize;
    } else {
      nextY += Math.sign(dy) * boxSize;
    }

    // Check collision with snake's body
    let collisionWithSnake = snake.body.some(segment => {
      return nextX === segment.x * boxSize && nextY === segment.y * boxSize;
    });

    // Check collision with other blocks
    let collisionWithBlock = blockList.some(otherBlock => {
      // Make sure we don't compare the block with itself
      if (otherBlock === block) return false;
      return nextX === otherBlock.x && nextY === otherBlock.y;
    });

    // Only move if both collisions are avoided
    if (!collisionWithSnake && !collisionWithBlock) {
      block.x = nextX;
      block.y = nextY;
    }
  }
}

//rival snake
//rival snake
const rivalSnake = new Snake();
rivalSnake.body = [{x: 5, y: 5}, {x: 4, y: 5}, {x: 3, y: 5}];
rivalSnake.direction = {x: 1, y: 0};

function rivalMove(){
  if (foodList.length === 0) return;

  const food = foodList[0];
  const head = rivalSnake.body[0];

  let dx = food.x / boxSize - head.x;
  let dy = food.y / boxSize - head.y;

  let options = [];
  if (dx !== 0) options.push({x: Math.sign(dx), y: 0});
  if (dy !== 0) options.push({x: 0, y: Math.sign(dy)});
  
  // Add a bit of randomness
  if (Math.random() < 0.2 || options.length === 0) {
    const dirs = [
      {x: 0, y: -1},
      {x: 0, y: 1},
      {x: -1, y: 0},
      {x: 1, y: 0}
    ];
    options = dirs.sort(() => 0.5 - Math.random());
  }

  for (let dir of options){
    const nextX = head.x + dir.x;
    const nextY = head.y + dir.y;
    
    // Avoid walls, itself, blocks, and player snake
    const inBounds = enableBorders 
      ? (nextX >= 0 && nextX < gridSize && nextY >= 0 && nextY < gridSize)
      : true;

    const collides = rivalSnake.body.some(p => p.x === nextX && p.y === nextY) ||
                     snake.body.some(p => p.x === nextX && p.y === nextY) ||
                     blockList.some(b => b.x / boxSize === nextX && b.y / boxSize === nextY);

    if (inBounds && !collides){
      rivalSnake.changeDirection(dir);
      break;
    }
  }

  rivalSnake.move();
}
function rivalEat(){
  if (foodList.length < 1) return;

  const head = rivalSnake.body[0];
  const food = foodList[0];

  if (head.x === food.x / boxSize && head.y === food.y / boxSize){
    rivalSnake.body.push({...rivalSnake.body[rivalSnake.body.length - 1]});
    foodList.pop();
    resetFoodTimer();
    if (foodTimerEnabled) startFoodTimer();
  }
}
function detectCollisionWithRival(){
  const head = snake.body[0];
  for (let i = 0; i < rivalSnake.body.length; i++){
    if (head.x === rivalSnake.body[i].x && head.y === rivalSnake.body[i].y){
      reset(); // Game over
    }
  }
}
